# 295. Find Median from Data Stream

标签（空格分隔）： leetcode

---

[题目地址][1]

```
import java.util.ArrayList;
public class MedianFinder {
	ArrayList<Integer> al=new ArrayList<Integer>();
	public void addNum(int num) {
		al.add(num);
		//插入排序
		for (int i = 0; i < al.size(); i++) {
			if (num > al.get(i)) {
				for (int j = al.size()-1; j > i; j--) {
					al.set(j, al.get(j-1));
				}
				al.set(i, num);
				break;
			}
		}
	}
	public double findMedian() {
		int size = al.size();
		if(size % 2 == 1)
			return al.get(size/2);
		return (al.get(size/2-1)+al.get(size/2)) / 2.0;
	}
}
```
一个巧妙的做法
```
PriorityQueue<Integer> minHeap = new PriorityQueue<>();//heap is a minimal heap by default
PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());//change to a maximum heap

// Adds a number into the data structure.
public void addNum(int num) {
    maxHeap.offer(num);
    minHeap.offer(maxHeap.poll());
    if (maxHeap.size() < minHeap.size())
        maxHeap.offer(minHeap.poll());
}

// Returns the median of current data stream
public double findMedian() {
    if (maxHeap.size() == minHeap.size())
        return (maxHeap.peek() + minHeap.peek()) / 2.0;
    else
        return maxHeap.peek();
}
```
该算法的思路是设立两个堆，一个为大根堆，一个为小根堆。将排好序的序列前半部分放入大根堆中，将序列的后半部分放入小根堆中，要保证小根堆中的数目不多于大根堆中的数目。如果为奇数时，大根堆中的根元素就为中位数，如果为偶数，则需要将两个堆中的根元素相加求平均值。

  [1]: https://leetcode.com/problems/find-median-from-data-stream